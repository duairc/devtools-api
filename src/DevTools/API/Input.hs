{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TypeFamilies #-}

{-# OPTIONS_GHC -fno-warn-deprecations #-}
{-# OPTIONS_GHC -fno-warn-dodgy-exports #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}

module DevTools.API.Input
    ( module DevTools.API.Input.Types
    , module DevTools.API.Input
    ) 
where

-- aeson----------------------------------------------------------------------
import           Data.Aeson ((.:), (.:?), (.=))
import qualified Data.Aeson as A
                     ( FromJSON, ToJSON, Object, Value (Null)
                     , parseJSON, withText, withArray, withObject
                     , toEncoding, pairs, toJSON, object
                     )


-- base-----------------------------------------------------------------------
import           Control.Applicative ((<|>), (<*>))
import qualified Control.Applicative as P (empty)
import qualified Data.Foldable as P (fold)
import           Data.Function (($))
import           Data.Functor ((<$>))
import qualified Data.Maybe as P (catMaybes)
import qualified Data.Proxy as P (Proxy (Proxy))
import qualified Data.Typeable as P (Typeable)
import qualified GHC.Generics as P (Generic)
import qualified Prelude as P


-- deepseq--------------------------------------------------------------------
import qualified Control.DeepSeq as D (NFData)


-- devtools-------------------------------------------------------------------
import qualified DevTools.Event as E (Event, Result, name)
import qualified DevTools.Method as M (Method, Result, name)


-- devtools-api---------------------------------------------------------------
import           DevTools.API.Input.Types


-- hashable-------------------------------------------------------------------
import qualified Data.Hashable as H (Hashable)


-- text-----------------------------------------------------------------------
import qualified Data.Text as T


-- vector---------------------------------------------------------------------
import           Data.Vector ((!?))


------------------------------------------------------------------------------
-- | Dispatches a key event to the page.
data DispatchKeyEvent = DispatchKeyEvent
    { -- | Type of the key event.
      type_ :: !Type
      -- | Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta\/Command=4, Shift=8
      -- (default: 0).
    , modifiers :: !(P.Maybe P.Int)
      -- | Time at which the event occurred.
    , timestamp :: !(P.Maybe TimeSinceEpoch)
      -- | Text as generated by processing a virtual key code with a keyboard layout. Not needed for
      -- for @keyUp@ and @rawKeyDown@ events (default: "")
    , text :: !(P.Maybe T.Text)
      -- | Text that would have been generated by the keyboard if no modifiers were pressed (except for
      -- shift). Useful for shortcut (accelerator) key handling (default: "").
    , unmodifiedText :: !(P.Maybe T.Text)
      -- | Unique key identifier (e.g., 'U+0041') (default: "").
    , keyIdentifier :: !(P.Maybe T.Text)
      -- | Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
    , code :: !(P.Maybe T.Text)
      -- | Unique DOM defined string value describing the meaning of the key in the context of active
      -- modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
    , key :: !(P.Maybe T.Text)
      -- | Windows virtual key code (default: 0).
    , windowsVirtualKeyCode :: !(P.Maybe P.Int)
      -- | Native virtual key code (default: 0).
    , nativeVirtualKeyCode :: !(P.Maybe P.Int)
      -- | Whether the event was generated from auto repeat (default: false).
    , autoRepeat :: !(P.Maybe P.Bool)
      -- | Whether the event was generated from the keypad (default: false).
    , isKeypad :: !(P.Maybe P.Bool)
      -- | Whether the event was a system key event (default: false).
    , isSystemKey :: !(P.Maybe P.Bool)
      -- | Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default:
      -- 0).
    , location :: !(P.Maybe P.Int)
    }
  deriving
    ( P.Eq, P.Ord, P.Read, P.Show, P.Generic, P.Typeable
    , D.NFData, H.Hashable
    )


------------------------------------------------------------------------------
instance A.FromJSON DispatchKeyEvent where
    parseJSON v = ago v <|> ogo v
      where
        ogo = A.withObject "dispatchKeyEvent" $ \_o -> DispatchKeyEvent
            <$> _o .: "type"
            <*> _o .:? "modifiers"
            <*> _o .:? "timestamp"
            <*> _o .:? "text"
            <*> _o .:? "unmodifiedText"
            <*> _o .:? "keyIdentifier"
            <*> _o .:? "code"
            <*> _o .:? "key"
            <*> _o .:? "windowsVirtualKeyCode"
            <*> _o .:? "nativeVirtualKeyCode"
            <*> _o .:? "autoRepeat"
            <*> _o .:? "isKeypad"
            <*> _o .:? "isSystemKey"
            <*> _o .:? "location"
        ago = A.withArray "dispatchKeyEvent" $ \_a -> DispatchKeyEvent
            <$> P.maybe P.empty A.parseJSON (_a !? 0)
            <*> P.traverse A.parseJSON (_a !? 1)
            <*> P.traverse A.parseJSON (_a !? 2)
            <*> P.traverse A.parseJSON (_a !? 3)
            <*> P.traverse A.parseJSON (_a !? 4)
            <*> P.traverse A.parseJSON (_a !? 5)
            <*> P.traverse A.parseJSON (_a !? 6)
            <*> P.traverse A.parseJSON (_a !? 7)
            <*> P.traverse A.parseJSON (_a !? 8)
            <*> P.traverse A.parseJSON (_a !? 9)
            <*> P.traverse A.parseJSON (_a !? 10)
            <*> P.traverse A.parseJSON (_a !? 11)
            <*> P.traverse A.parseJSON (_a !? 12)
            <*> P.traverse A.parseJSON (_a !? 13)


------------------------------------------------------------------------------
instance A.ToJSON DispatchKeyEvent where
    toEncoding (DispatchKeyEvent _0 _1 _2 _3 _4 _5 _6 _7 _8 _9 _10 _11 _12 _13) = A.pairs $ P.fold $ P.catMaybes
        [ P.pure $ "type" .= _0
        , ("modifiers" .=) <$> _1
        , ("timestamp" .=) <$> _2
        , ("text" .=) <$> _3
        , ("unmodifiedText" .=) <$> _4
        , ("keyIdentifier" .=) <$> _5
        , ("code" .=) <$> _6
        , ("key" .=) <$> _7
        , ("windowsVirtualKeyCode" .=) <$> _8
        , ("nativeVirtualKeyCode" .=) <$> _9
        , ("autoRepeat" .=) <$> _10
        , ("isKeypad" .=) <$> _11
        , ("isSystemKey" .=) <$> _12
        , ("location" .=) <$> _13
        ]
    toJSON (DispatchKeyEvent _0 _1 _2 _3 _4 _5 _6 _7 _8 _9 _10 _11 _12 _13) = A.object $ P.catMaybes
        [ P.pure $ "type" .= _0
        , ("modifiers" .=) <$> _1
        , ("timestamp" .=) <$> _2
        , ("text" .=) <$> _3
        , ("unmodifiedText" .=) <$> _4
        , ("keyIdentifier" .=) <$> _5
        , ("code" .=) <$> _6
        , ("key" .=) <$> _7
        , ("windowsVirtualKeyCode" .=) <$> _8
        , ("nativeVirtualKeyCode" .=) <$> _9
        , ("autoRepeat" .=) <$> _10
        , ("isKeypad" .=) <$> _11
        , ("isSystemKey" .=) <$> _12
        , ("location" .=) <$> _13
        ]


------------------------------------------------------------------------------
instance P.Semigroup DispatchKeyEvent where
    DispatchKeyEvent _0 _1 _2 _3 _4 _5 _6 _7 _8 _9 _10 _11 _12 _13 <> DispatchKeyEvent _ __1 __2 __3 __4 __5 __6 __7 __8 __9 __10 __11 __12 __13 = DispatchKeyEvent _0 (_1 <|> __1) (_2 <|> __2) (_3 <|> __3) (_4 <|> __4) (_5 <|> __5) (_6 <|> __6) (_7 <|> __7) (_8 <|> __8) (_9 <|> __9) (_10 <|> __10) (_11 <|> __11) (_12 <|> __12) (_13 <|> __13)


------------------------------------------------------------------------------
data Type
    = KeyDown
    | KeyUp
    | RawKeyDown
    | Char
  deriving
    ( P.Eq, P.Ord, P.Read, P.Show, P.Enum, P.Bounded, P.Generic, P.Typeable
    , D.NFData, H.Hashable
    )


------------------------------------------------------------------------------
instance A.FromJSON Type where
    parseJSON = A.withText "Type" $ \t -> case t of
        "keyDown" -> P.pure KeyDown
        "keyUp" -> P.pure KeyUp
        "rawKeyDown" -> P.pure RawKeyDown
        "char" -> P.pure Char
        _ -> P.empty


------------------------------------------------------------------------------
instance A.ToJSON Type where
    toJSON KeyDown = "keyDown"
    toJSON KeyUp = "keyUp"
    toJSON RawKeyDown = "rawKeyDown"
    toJSON Char = "char"


------------------------------------------------------------------------------
instance M.Method DispatchKeyEvent where
    type Result DispatchKeyEvent = ()
    name _ = "Input.dispatchKeyEvent"


------------------------------------------------------------------------------
-- | Dispatches a key event to the page.
dispatchKeyEvent
    :: Type
    -- ^ Type of the key event.

    -> DispatchKeyEvent
dispatchKeyEvent _0 = DispatchKeyEvent _0 P.empty P.empty P.empty P.empty P.empty P.empty P.empty P.empty P.empty P.empty P.empty P.empty P.empty


------------------------------------------------------------------------------
-- | This method emulates inserting text that doesn't come from a key press,
-- for example an emoji keyboard or an IME.
{-# WARNING InsertText "This feature is marked as EXPERIMENTAL." #-}
data InsertText = InsertText
    { -- | The text to insert.
      text :: !T.Text
    }
  deriving
    ( P.Eq, P.Ord, P.Read, P.Show, P.Generic, P.Typeable
    , D.NFData, H.Hashable
    )


------------------------------------------------------------------------------
instance A.FromJSON InsertText where
    parseJSON v = ago v <|> ogo v
      where
        ogo = A.withObject "insertText" $ \_o -> InsertText
            <$> _o .: "text"
        ago = A.withArray "insertText" $ \_a -> InsertText
            <$> P.maybe P.empty A.parseJSON (_a !? 0)


------------------------------------------------------------------------------
instance A.ToJSON InsertText where
    toEncoding (InsertText _0) = A.pairs $ P.fold $ P.catMaybes
        [ P.pure $ "text" .= _0
        ]
    toJSON (InsertText _0) = A.object $ P.catMaybes
        [ P.pure $ "text" .= _0
        ]


------------------------------------------------------------------------------
instance P.Semigroup InsertText where
    InsertText _0 <> InsertText _ = InsertText _0


------------------------------------------------------------------------------
instance M.Method InsertText where
    type Result InsertText = ()
    name _ = "Input.insertText"


------------------------------------------------------------------------------
-- | This method emulates inserting text that doesn't come from a key press,
-- for example an emoji keyboard or an IME.
{-# WARNING insertText "This feature is marked as EXPERIMENTAL." #-}
insertText
    :: T.Text
    -- ^ The text to insert.

    -> InsertText
insertText _0 = InsertText _0


------------------------------------------------------------------------------
-- | Dispatches a mouse event to the page.
data DispatchMouseEvent = DispatchMouseEvent
    { -- | Type of the mouse event.
      type_ :: !Type_
      -- | X coordinate of the event relative to the main frame's viewport in CSS pixels.
    , x :: !P.Double
      -- | Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to
      -- the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
    , y :: !P.Double
      -- | Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta\/Command=4, Shift=8
      -- (default: 0).
    , modifiers :: !(P.Maybe P.Int)
      -- | Time at which the event occurred.
    , timestamp :: !(P.Maybe TimeSinceEpoch)
      -- | Mouse button (default: "none").
    , button :: !(P.Maybe Button)
      -- | A number indicating which buttons are pressed on the mouse when a mouse event is triggered.
      -- Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
    , buttons :: !(P.Maybe P.Int)
      -- | Number of times the mouse button was clicked (default: 0).
    , clickCount :: !(P.Maybe P.Int)
      -- | X delta in CSS pixels for mouse wheel event (default: 0).
    , deltaX :: !(P.Maybe P.Double)
      -- | Y delta in CSS pixels for mouse wheel event (default: 0).
    , deltaY :: !(P.Maybe P.Double)
      -- | Pointer type (default: "mouse").
    , pointerType :: !(P.Maybe PointerType)
    }
  deriving
    ( P.Eq, P.Ord, P.Read, P.Show, P.Generic, P.Typeable
    , D.NFData, H.Hashable
    )


------------------------------------------------------------------------------
instance A.FromJSON DispatchMouseEvent where
    parseJSON v = ago v <|> ogo v
      where
        ogo = A.withObject "dispatchMouseEvent" $ \_o -> DispatchMouseEvent
            <$> _o .: "type"
            <*> _o .: "x"
            <*> _o .: "y"
            <*> _o .:? "modifiers"
            <*> _o .:? "timestamp"
            <*> _o .:? "button"
            <*> _o .:? "buttons"
            <*> _o .:? "clickCount"
            <*> _o .:? "deltaX"
            <*> _o .:? "deltaY"
            <*> _o .:? "pointerType"
        ago = A.withArray "dispatchMouseEvent" $ \_a -> DispatchMouseEvent
            <$> P.maybe P.empty A.parseJSON (_a !? 0)
            <*> P.maybe P.empty A.parseJSON (_a !? 1)
            <*> P.maybe P.empty A.parseJSON (_a !? 2)
            <*> P.traverse A.parseJSON (_a !? 3)
            <*> P.traverse A.parseJSON (_a !? 4)
            <*> P.traverse A.parseJSON (_a !? 5)
            <*> P.traverse A.parseJSON (_a !? 6)
            <*> P.traverse A.parseJSON (_a !? 7)
            <*> P.traverse A.parseJSON (_a !? 8)
            <*> P.traverse A.parseJSON (_a !? 9)
            <*> P.traverse A.parseJSON (_a !? 10)


------------------------------------------------------------------------------
instance A.ToJSON DispatchMouseEvent where
    toEncoding (DispatchMouseEvent _0 _1 _2 _3 _4 _5 _6 _7 _8 _9 _10) = A.pairs $ P.fold $ P.catMaybes
        [ P.pure $ "type" .= _0
        , P.pure $ "x" .= _1
        , P.pure $ "y" .= _2
        , ("modifiers" .=) <$> _3
        , ("timestamp" .=) <$> _4
        , ("button" .=) <$> _5
        , ("buttons" .=) <$> _6
        , ("clickCount" .=) <$> _7
        , ("deltaX" .=) <$> _8
        , ("deltaY" .=) <$> _9
        , ("pointerType" .=) <$> _10
        ]
    toJSON (DispatchMouseEvent _0 _1 _2 _3 _4 _5 _6 _7 _8 _9 _10) = A.object $ P.catMaybes
        [ P.pure $ "type" .= _0
        , P.pure $ "x" .= _1
        , P.pure $ "y" .= _2
        , ("modifiers" .=) <$> _3
        , ("timestamp" .=) <$> _4
        , ("button" .=) <$> _5
        , ("buttons" .=) <$> _6
        , ("clickCount" .=) <$> _7
        , ("deltaX" .=) <$> _8
        , ("deltaY" .=) <$> _9
        , ("pointerType" .=) <$> _10
        ]


------------------------------------------------------------------------------
instance P.Semigroup DispatchMouseEvent where
    DispatchMouseEvent _0 _1 _2 _3 _4 _5 _6 _7 _8 _9 _10 <> DispatchMouseEvent _ _ _ __3 __4 __5 __6 __7 __8 __9 __10 = DispatchMouseEvent _0 _1 _2 (_3 <|> __3) (_4 <|> __4) (_5 <|> __5) (_6 <|> __6) (_7 <|> __7) (_8 <|> __8) (_9 <|> __9) (_10 <|> __10)


------------------------------------------------------------------------------
data Type_
    = MousePressed
    | MouseReleased
    | MouseMoved
    | MouseWheel
  deriving
    ( P.Eq, P.Ord, P.Read, P.Show, P.Enum, P.Bounded, P.Generic, P.Typeable
    , D.NFData, H.Hashable
    )


------------------------------------------------------------------------------
instance A.FromJSON Type_ where
    parseJSON = A.withText "Type" $ \t -> case t of
        "mousePressed" -> P.pure MousePressed
        "mouseReleased" -> P.pure MouseReleased
        "mouseMoved" -> P.pure MouseMoved
        "mouseWheel" -> P.pure MouseWheel
        _ -> P.empty


------------------------------------------------------------------------------
instance A.ToJSON Type_ where
    toJSON MousePressed = "mousePressed"
    toJSON MouseReleased = "mouseReleased"
    toJSON MouseMoved = "mouseMoved"
    toJSON MouseWheel = "mouseWheel"


------------------------------------------------------------------------------
data Button
    = None
    | Left
    | Middle
    | Right
    | Back
    | Forward
  deriving
    ( P.Eq, P.Ord, P.Read, P.Show, P.Enum, P.Bounded, P.Generic, P.Typeable
    , D.NFData, H.Hashable
    )


------------------------------------------------------------------------------
instance A.FromJSON Button where
    parseJSON = A.withText "Button" $ \t -> case t of
        "none" -> P.pure None
        "left" -> P.pure Left
        "middle" -> P.pure Middle
        "right" -> P.pure Right
        "back" -> P.pure Back
        "forward" -> P.pure Forward
        _ -> P.empty


------------------------------------------------------------------------------
instance A.ToJSON Button where
    toJSON None = "none"
    toJSON Left = "left"
    toJSON Middle = "middle"
    toJSON Right = "right"
    toJSON Back = "back"
    toJSON Forward = "forward"


------------------------------------------------------------------------------
data PointerType
    = Mouse_
    | Pen
  deriving
    ( P.Eq, P.Ord, P.Read, P.Show, P.Enum, P.Bounded, P.Generic, P.Typeable
    , D.NFData, H.Hashable
    )


------------------------------------------------------------------------------
instance A.FromJSON PointerType where
    parseJSON = A.withText "PointerType" $ \t -> case t of
        "mouse" -> P.pure Mouse_
        "pen" -> P.pure Pen
        _ -> P.empty


------------------------------------------------------------------------------
instance A.ToJSON PointerType where
    toJSON Mouse_ = "mouse"
    toJSON Pen = "pen"


------------------------------------------------------------------------------
instance M.Method DispatchMouseEvent where
    type Result DispatchMouseEvent = ()
    name _ = "Input.dispatchMouseEvent"


------------------------------------------------------------------------------
-- | Dispatches a mouse event to the page.
dispatchMouseEvent
    :: Type_
    -- ^ Type of the mouse event.

    -> P.Double
    -- ^ X coordinate of the event relative to the main frame's viewport in CSS pixels.

    -> P.Double
    -- ^ Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to

    -- the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.

    -> DispatchMouseEvent
dispatchMouseEvent _0 _1 _2 = DispatchMouseEvent _0 _1 _2 P.empty P.empty P.empty P.empty P.empty P.empty P.empty P.empty


------------------------------------------------------------------------------
-- | Dispatches a touch event to the page.
data DispatchTouchEvent = DispatchTouchEvent
    { -- | Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while
      -- TouchStart and TouchMove must contains at least one.
      type_ :: !Type__
      -- | Active touch points on the touch device. One event per any changed point (compared to
      -- previous touch event in a sequence) is generated, emulating pressing\/moving\/releasing points
      -- one by one.
    , touchPoints :: ![TouchPoint]
      -- | Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta\/Command=4, Shift=8
      -- (default: 0).
    , modifiers :: !(P.Maybe P.Int)
      -- | Time at which the event occurred.
    , timestamp :: !(P.Maybe TimeSinceEpoch)
    }
  deriving
    ( P.Eq, P.Ord, P.Read, P.Show, P.Generic, P.Typeable
    , D.NFData, H.Hashable
    )


------------------------------------------------------------------------------
instance A.FromJSON DispatchTouchEvent where
    parseJSON v = ago v <|> ogo v
      where
        ogo = A.withObject "dispatchTouchEvent" $ \_o -> DispatchTouchEvent
            <$> _o .: "type"
            <*> _o .: "touchPoints"
            <*> _o .:? "modifiers"
            <*> _o .:? "timestamp"
        ago = A.withArray "dispatchTouchEvent" $ \_a -> DispatchTouchEvent
            <$> P.maybe P.empty A.parseJSON (_a !? 0)
            <*> P.maybe P.empty A.parseJSON (_a !? 1)
            <*> P.traverse A.parseJSON (_a !? 2)
            <*> P.traverse A.parseJSON (_a !? 3)


------------------------------------------------------------------------------
instance A.ToJSON DispatchTouchEvent where
    toEncoding (DispatchTouchEvent _0 _1 _2 _3) = A.pairs $ P.fold $ P.catMaybes
        [ P.pure $ "type" .= _0
        , P.pure $ "touchPoints" .= _1
        , ("modifiers" .=) <$> _2
        , ("timestamp" .=) <$> _3
        ]
    toJSON (DispatchTouchEvent _0 _1 _2 _3) = A.object $ P.catMaybes
        [ P.pure $ "type" .= _0
        , P.pure $ "touchPoints" .= _1
        , ("modifiers" .=) <$> _2
        , ("timestamp" .=) <$> _3
        ]


------------------------------------------------------------------------------
instance P.Semigroup DispatchTouchEvent where
    DispatchTouchEvent _0 _1 _2 _3 <> DispatchTouchEvent _ _ __2 __3 = DispatchTouchEvent _0 _1 (_2 <|> __2) (_3 <|> __3)


------------------------------------------------------------------------------
data Type__
    = TouchStart
    | TouchEnd
    | TouchMove
    | TouchCancel
  deriving
    ( P.Eq, P.Ord, P.Read, P.Show, P.Enum, P.Bounded, P.Generic, P.Typeable
    , D.NFData, H.Hashable
    )


------------------------------------------------------------------------------
instance A.FromJSON Type__ where
    parseJSON = A.withText "Type" $ \t -> case t of
        "touchStart" -> P.pure TouchStart
        "touchEnd" -> P.pure TouchEnd
        "touchMove" -> P.pure TouchMove
        "touchCancel" -> P.pure TouchCancel
        _ -> P.empty


------------------------------------------------------------------------------
instance A.ToJSON Type__ where
    toJSON TouchStart = "touchStart"
    toJSON TouchEnd = "touchEnd"
    toJSON TouchMove = "touchMove"
    toJSON TouchCancel = "touchCancel"


------------------------------------------------------------------------------
instance M.Method DispatchTouchEvent where
    type Result DispatchTouchEvent = ()
    name _ = "Input.dispatchTouchEvent"


------------------------------------------------------------------------------
-- | Dispatches a touch event to the page.
dispatchTouchEvent
    :: Type__
    -- ^ Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while

    -- TouchStart and TouchMove must contains at least one.

    -> [TouchPoint]
    -- ^ Active touch points on the touch device. One event per any changed point (compared to

    -- previous touch event in a sequence) is generated, emulating pressing\/moving\/releasing points

    -- one by one.

    -> DispatchTouchEvent
dispatchTouchEvent _0 _1 = DispatchTouchEvent _0 _1 P.empty P.empty


------------------------------------------------------------------------------
-- | Emulates touch event from the mouse event parameters.
{-# WARNING EmulateTouchFromMouseEvent "This feature is marked as EXPERIMENTAL." #-}
data EmulateTouchFromMouseEvent = EmulateTouchFromMouseEvent
    { -- | Type of the mouse event.
      type_ :: !Type_
      -- | X coordinate of the mouse pointer in DIP.
    , x :: !P.Int
      -- | Y coordinate of the mouse pointer in DIP.
    , y :: !P.Int
      -- | Mouse button.
    , button :: !Button_
      -- | Time at which the event occurred (default: current time).
    , timestamp :: !(P.Maybe TimeSinceEpoch)
      -- | X delta in DIP for mouse wheel event (default: 0).
    , deltaX :: !(P.Maybe P.Double)
      -- | Y delta in DIP for mouse wheel event (default: 0).
    , deltaY :: !(P.Maybe P.Double)
      -- | Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta\/Command=4, Shift=8
      -- (default: 0).
    , modifiers :: !(P.Maybe P.Int)
      -- | Number of times the mouse button was clicked (default: 0).
    , clickCount :: !(P.Maybe P.Int)
    }
  deriving
    ( P.Eq, P.Ord, P.Read, P.Show, P.Generic, P.Typeable
    , D.NFData, H.Hashable
    )


------------------------------------------------------------------------------
instance A.FromJSON EmulateTouchFromMouseEvent where
    parseJSON v = ago v <|> ogo v
      where
        ogo = A.withObject "emulateTouchFromMouseEvent" $ \_o -> EmulateTouchFromMouseEvent
            <$> _o .: "type"
            <*> _o .: "x"
            <*> _o .: "y"
            <*> _o .: "button"
            <*> _o .:? "timestamp"
            <*> _o .:? "deltaX"
            <*> _o .:? "deltaY"
            <*> _o .:? "modifiers"
            <*> _o .:? "clickCount"
        ago = A.withArray "emulateTouchFromMouseEvent" $ \_a -> EmulateTouchFromMouseEvent
            <$> P.maybe P.empty A.parseJSON (_a !? 0)
            <*> P.maybe P.empty A.parseJSON (_a !? 1)
            <*> P.maybe P.empty A.parseJSON (_a !? 2)
            <*> P.maybe P.empty A.parseJSON (_a !? 3)
            <*> P.traverse A.parseJSON (_a !? 4)
            <*> P.traverse A.parseJSON (_a !? 5)
            <*> P.traverse A.parseJSON (_a !? 6)
            <*> P.traverse A.parseJSON (_a !? 7)
            <*> P.traverse A.parseJSON (_a !? 8)


------------------------------------------------------------------------------
instance A.ToJSON EmulateTouchFromMouseEvent where
    toEncoding (EmulateTouchFromMouseEvent _0 _1 _2 _3 _4 _5 _6 _7 _8) = A.pairs $ P.fold $ P.catMaybes
        [ P.pure $ "type" .= _0
        , P.pure $ "x" .= _1
        , P.pure $ "y" .= _2
        , P.pure $ "button" .= _3
        , ("timestamp" .=) <$> _4
        , ("deltaX" .=) <$> _5
        , ("deltaY" .=) <$> _6
        , ("modifiers" .=) <$> _7
        , ("clickCount" .=) <$> _8
        ]
    toJSON (EmulateTouchFromMouseEvent _0 _1 _2 _3 _4 _5 _6 _7 _8) = A.object $ P.catMaybes
        [ P.pure $ "type" .= _0
        , P.pure $ "x" .= _1
        , P.pure $ "y" .= _2
        , P.pure $ "button" .= _3
        , ("timestamp" .=) <$> _4
        , ("deltaX" .=) <$> _5
        , ("deltaY" .=) <$> _6
        , ("modifiers" .=) <$> _7
        , ("clickCount" .=) <$> _8
        ]


------------------------------------------------------------------------------
instance P.Semigroup EmulateTouchFromMouseEvent where
    EmulateTouchFromMouseEvent _0 _1 _2 _3 _4 _5 _6 _7 _8 <> EmulateTouchFromMouseEvent _ _ _ _ __4 __5 __6 __7 __8 = EmulateTouchFromMouseEvent _0 _1 _2 _3 (_4 <|> __4) (_5 <|> __5) (_6 <|> __6) (_7 <|> __7) (_8 <|> __8)


------------------------------------------------------------------------------
data Button_
    = None_
    | Left_
    | Middle_
    | Right_
  deriving
    ( P.Eq, P.Ord, P.Read, P.Show, P.Enum, P.Bounded, P.Generic, P.Typeable
    , D.NFData, H.Hashable
    )


------------------------------------------------------------------------------
instance A.FromJSON Button_ where
    parseJSON = A.withText "Button" $ \t -> case t of
        "none" -> P.pure None_
        "left" -> P.pure Left_
        "middle" -> P.pure Middle_
        "right" -> P.pure Right_
        _ -> P.empty


------------------------------------------------------------------------------
instance A.ToJSON Button_ where
    toJSON None_ = "none"
    toJSON Left_ = "left"
    toJSON Middle_ = "middle"
    toJSON Right_ = "right"


------------------------------------------------------------------------------
instance M.Method EmulateTouchFromMouseEvent where
    type Result EmulateTouchFromMouseEvent = ()
    name _ = "Input.emulateTouchFromMouseEvent"


------------------------------------------------------------------------------
-- | Emulates touch event from the mouse event parameters.
{-# WARNING emulateTouchFromMouseEvent "This feature is marked as EXPERIMENTAL." #-}
emulateTouchFromMouseEvent
    :: Type_
    -- ^ Type of the mouse event.

    -> P.Int
    -- ^ X coordinate of the mouse pointer in DIP.

    -> P.Int
    -- ^ Y coordinate of the mouse pointer in DIP.

    -> Button_
    -- ^ Mouse button.

    -> EmulateTouchFromMouseEvent
emulateTouchFromMouseEvent _0 _1 _2 _3 = EmulateTouchFromMouseEvent _0 _1 _2 _3 P.empty P.empty P.empty P.empty P.empty


------------------------------------------------------------------------------
-- | Ignores input events (useful while auditing page).
data SetIgnoreInputEvents = SetIgnoreInputEvents
    { -- | Ignores input events processing when set to true.
      ignore :: !P.Bool
    }
  deriving
    ( P.Eq, P.Ord, P.Read, P.Show, P.Generic, P.Typeable
    , D.NFData, H.Hashable
    )


------------------------------------------------------------------------------
instance A.FromJSON SetIgnoreInputEvents where
    parseJSON v = ago v <|> ogo v
      where
        ogo = A.withObject "setIgnoreInputEvents" $ \_o -> SetIgnoreInputEvents
            <$> _o .: "ignore"
        ago = A.withArray "setIgnoreInputEvents" $ \_a -> SetIgnoreInputEvents
            <$> P.maybe P.empty A.parseJSON (_a !? 0)


------------------------------------------------------------------------------
instance A.ToJSON SetIgnoreInputEvents where
    toEncoding (SetIgnoreInputEvents _0) = A.pairs $ P.fold $ P.catMaybes
        [ P.pure $ "ignore" .= _0
        ]
    toJSON (SetIgnoreInputEvents _0) = A.object $ P.catMaybes
        [ P.pure $ "ignore" .= _0
        ]


------------------------------------------------------------------------------
instance P.Semigroup SetIgnoreInputEvents where
    SetIgnoreInputEvents _0 <> SetIgnoreInputEvents _ = SetIgnoreInputEvents _0


------------------------------------------------------------------------------
instance M.Method SetIgnoreInputEvents where
    type Result SetIgnoreInputEvents = ()
    name _ = "Input.setIgnoreInputEvents"


------------------------------------------------------------------------------
-- | Ignores input events (useful while auditing page).
setIgnoreInputEvents
    :: P.Bool
    -- ^ Ignores input events processing when set to true.

    -> SetIgnoreInputEvents
setIgnoreInputEvents _0 = SetIgnoreInputEvents _0


------------------------------------------------------------------------------
-- | Synthesizes a pinch gesture over a time period by issuing appropriate touch events.
{-# WARNING SynthesizePinchGesture "This feature is marked as EXPERIMENTAL." #-}
data SynthesizePinchGesture = SynthesizePinchGesture
    { -- | X coordinate of the start of the gesture in CSS pixels.
      x :: !P.Double
      -- | Y coordinate of the start of the gesture in CSS pixels.
    , y :: !P.Double
      -- | Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
    , scaleFactor :: !P.Double
      -- | Relative pointer speed in pixels per second (default: 800).
    , relativeSpeed :: !(P.Maybe P.Int)
      -- | Which type of input events to be generated (default: 'default', which queries the platform
      -- for the preferred input type).
    , gestureSourceType :: !(P.Maybe GestureSourceType)
    }
  deriving
    ( P.Eq, P.Ord, P.Read, P.Show, P.Generic, P.Typeable
    , D.NFData, H.Hashable
    )


------------------------------------------------------------------------------
instance A.FromJSON SynthesizePinchGesture where
    parseJSON v = ago v <|> ogo v
      where
        ogo = A.withObject "synthesizePinchGesture" $ \_o -> SynthesizePinchGesture
            <$> _o .: "x"
            <*> _o .: "y"
            <*> _o .: "scaleFactor"
            <*> _o .:? "relativeSpeed"
            <*> _o .:? "gestureSourceType"
        ago = A.withArray "synthesizePinchGesture" $ \_a -> SynthesizePinchGesture
            <$> P.maybe P.empty A.parseJSON (_a !? 0)
            <*> P.maybe P.empty A.parseJSON (_a !? 1)
            <*> P.maybe P.empty A.parseJSON (_a !? 2)
            <*> P.traverse A.parseJSON (_a !? 3)
            <*> P.traverse A.parseJSON (_a !? 4)


------------------------------------------------------------------------------
instance A.ToJSON SynthesizePinchGesture where
    toEncoding (SynthesizePinchGesture _0 _1 _2 _3 _4) = A.pairs $ P.fold $ P.catMaybes
        [ P.pure $ "x" .= _0
        , P.pure $ "y" .= _1
        , P.pure $ "scaleFactor" .= _2
        , ("relativeSpeed" .=) <$> _3
        , ("gestureSourceType" .=) <$> _4
        ]
    toJSON (SynthesizePinchGesture _0 _1 _2 _3 _4) = A.object $ P.catMaybes
        [ P.pure $ "x" .= _0
        , P.pure $ "y" .= _1
        , P.pure $ "scaleFactor" .= _2
        , ("relativeSpeed" .=) <$> _3
        , ("gestureSourceType" .=) <$> _4
        ]


------------------------------------------------------------------------------
instance P.Semigroup SynthesizePinchGesture where
    SynthesizePinchGesture _0 _1 _2 _3 _4 <> SynthesizePinchGesture _ _ _ __3 __4 = SynthesizePinchGesture _0 _1 _2 (_3 <|> __3) (_4 <|> __4)


------------------------------------------------------------------------------
instance M.Method SynthesizePinchGesture where
    type Result SynthesizePinchGesture = ()
    name _ = "Input.synthesizePinchGesture"


------------------------------------------------------------------------------
-- | Synthesizes a pinch gesture over a time period by issuing appropriate touch events.
{-# WARNING synthesizePinchGesture "This feature is marked as EXPERIMENTAL." #-}
synthesizePinchGesture
    :: P.Double
    -- ^ X coordinate of the start of the gesture in CSS pixels.

    -> P.Double
    -- ^ Y coordinate of the start of the gesture in CSS pixels.

    -> P.Double
    -- ^ Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).

    -> SynthesizePinchGesture
synthesizePinchGesture _0 _1 _2 = SynthesizePinchGesture _0 _1 _2 P.empty P.empty


------------------------------------------------------------------------------
-- | Synthesizes a scroll gesture over a time period by issuing appropriate touch events.
{-# WARNING SynthesizeScrollGesture "This feature is marked as EXPERIMENTAL." #-}
data SynthesizeScrollGesture = SynthesizeScrollGesture
    { -- | X coordinate of the start of the gesture in CSS pixels.
      x :: !P.Double
      -- | Y coordinate of the start of the gesture in CSS pixels.
    , y :: !P.Double
      -- | The distance to scroll along the X axis (positive to scroll left).
    , xDistance :: !(P.Maybe P.Double)
      -- | The distance to scroll along the Y axis (positive to scroll up).
    , yDistance :: !(P.Maybe P.Double)
      -- | The number of additional pixels to scroll back along the X axis, in addition to the given
      -- distance.
    , xOverscroll :: !(P.Maybe P.Double)
      -- | The number of additional pixels to scroll back along the Y axis, in addition to the given
      -- distance.
    , yOverscroll :: !(P.Maybe P.Double)
      -- | Prevent fling (default: true).
    , preventFling :: !(P.Maybe P.Bool)
      -- | Swipe speed in pixels per second (default: 800).
    , speed :: !(P.Maybe P.Int)
      -- | Which type of input events to be generated (default: 'default', which queries the platform
      -- for the preferred input type).
    , gestureSourceType :: !(P.Maybe GestureSourceType)
      -- | The number of times to repeat the gesture (default: 0).
    , repeatCount :: !(P.Maybe P.Int)
      -- | The number of milliseconds delay between each repeat. (default: 250).
    , repeatDelayMs :: !(P.Maybe P.Int)
      -- | The name of the interaction markers to generate, if not empty (default: "").
    , interactionMarkerName :: !(P.Maybe T.Text)
    }
  deriving
    ( P.Eq, P.Ord, P.Read, P.Show, P.Generic, P.Typeable
    , D.NFData, H.Hashable
    )


------------------------------------------------------------------------------
instance A.FromJSON SynthesizeScrollGesture where
    parseJSON v = ago v <|> ogo v
      where
        ogo = A.withObject "synthesizeScrollGesture" $ \_o -> SynthesizeScrollGesture
            <$> _o .: "x"
            <*> _o .: "y"
            <*> _o .:? "xDistance"
            <*> _o .:? "yDistance"
            <*> _o .:? "xOverscroll"
            <*> _o .:? "yOverscroll"
            <*> _o .:? "preventFling"
            <*> _o .:? "speed"
            <*> _o .:? "gestureSourceType"
            <*> _o .:? "repeatCount"
            <*> _o .:? "repeatDelayMs"
            <*> _o .:? "interactionMarkerName"
        ago = A.withArray "synthesizeScrollGesture" $ \_a -> SynthesizeScrollGesture
            <$> P.maybe P.empty A.parseJSON (_a !? 0)
            <*> P.maybe P.empty A.parseJSON (_a !? 1)
            <*> P.traverse A.parseJSON (_a !? 2)
            <*> P.traverse A.parseJSON (_a !? 3)
            <*> P.traverse A.parseJSON (_a !? 4)
            <*> P.traverse A.parseJSON (_a !? 5)
            <*> P.traverse A.parseJSON (_a !? 6)
            <*> P.traverse A.parseJSON (_a !? 7)
            <*> P.traverse A.parseJSON (_a !? 8)
            <*> P.traverse A.parseJSON (_a !? 9)
            <*> P.traverse A.parseJSON (_a !? 10)
            <*> P.traverse A.parseJSON (_a !? 11)


------------------------------------------------------------------------------
instance A.ToJSON SynthesizeScrollGesture where
    toEncoding (SynthesizeScrollGesture _0 _1 _2 _3 _4 _5 _6 _7 _8 _9 _10 _11) = A.pairs $ P.fold $ P.catMaybes
        [ P.pure $ "x" .= _0
        , P.pure $ "y" .= _1
        , ("xDistance" .=) <$> _2
        , ("yDistance" .=) <$> _3
        , ("xOverscroll" .=) <$> _4
        , ("yOverscroll" .=) <$> _5
        , ("preventFling" .=) <$> _6
        , ("speed" .=) <$> _7
        , ("gestureSourceType" .=) <$> _8
        , ("repeatCount" .=) <$> _9
        , ("repeatDelayMs" .=) <$> _10
        , ("interactionMarkerName" .=) <$> _11
        ]
    toJSON (SynthesizeScrollGesture _0 _1 _2 _3 _4 _5 _6 _7 _8 _9 _10 _11) = A.object $ P.catMaybes
        [ P.pure $ "x" .= _0
        , P.pure $ "y" .= _1
        , ("xDistance" .=) <$> _2
        , ("yDistance" .=) <$> _3
        , ("xOverscroll" .=) <$> _4
        , ("yOverscroll" .=) <$> _5
        , ("preventFling" .=) <$> _6
        , ("speed" .=) <$> _7
        , ("gestureSourceType" .=) <$> _8
        , ("repeatCount" .=) <$> _9
        , ("repeatDelayMs" .=) <$> _10
        , ("interactionMarkerName" .=) <$> _11
        ]


------------------------------------------------------------------------------
instance P.Semigroup SynthesizeScrollGesture where
    SynthesizeScrollGesture _0 _1 _2 _3 _4 _5 _6 _7 _8 _9 _10 _11 <> SynthesizeScrollGesture _ _ __2 __3 __4 __5 __6 __7 __8 __9 __10 __11 = SynthesizeScrollGesture _0 _1 (_2 <|> __2) (_3 <|> __3) (_4 <|> __4) (_5 <|> __5) (_6 <|> __6) (_7 <|> __7) (_8 <|> __8) (_9 <|> __9) (_10 <|> __10) (_11 <|> __11)


------------------------------------------------------------------------------
instance M.Method SynthesizeScrollGesture where
    type Result SynthesizeScrollGesture = ()
    name _ = "Input.synthesizeScrollGesture"


------------------------------------------------------------------------------
-- | Synthesizes a scroll gesture over a time period by issuing appropriate touch events.
{-# WARNING synthesizeScrollGesture "This feature is marked as EXPERIMENTAL." #-}
synthesizeScrollGesture
    :: P.Double
    -- ^ X coordinate of the start of the gesture in CSS pixels.

    -> P.Double
    -- ^ Y coordinate of the start of the gesture in CSS pixels.

    -> SynthesizeScrollGesture
synthesizeScrollGesture _0 _1 = SynthesizeScrollGesture _0 _1 P.empty P.empty P.empty P.empty P.empty P.empty P.empty P.empty P.empty P.empty


------------------------------------------------------------------------------
-- | Synthesizes a tap gesture over a time period by issuing appropriate touch events.
{-# WARNING SynthesizeTapGesture "This feature is marked as EXPERIMENTAL." #-}
data SynthesizeTapGesture = SynthesizeTapGesture
    { -- | X coordinate of the start of the gesture in CSS pixels.
      x :: !P.Double
      -- | Y coordinate of the start of the gesture in CSS pixels.
    , y :: !P.Double
      -- | Duration between touchdown and touchup events in ms (default: 50).
    , duration :: !(P.Maybe P.Int)
      -- | Number of times to perform the tap (e.g. 2 for double tap, default: 1).
    , tapCount :: !(P.Maybe P.Int)
      -- | Which type of input events to be generated (default: 'default', which queries the platform
      -- for the preferred input type).
    , gestureSourceType :: !(P.Maybe GestureSourceType)
    }
  deriving
    ( P.Eq, P.Ord, P.Read, P.Show, P.Generic, P.Typeable
    , D.NFData, H.Hashable
    )


------------------------------------------------------------------------------
instance A.FromJSON SynthesizeTapGesture where
    parseJSON v = ago v <|> ogo v
      where
        ogo = A.withObject "synthesizeTapGesture" $ \_o -> SynthesizeTapGesture
            <$> _o .: "x"
            <*> _o .: "y"
            <*> _o .:? "duration"
            <*> _o .:? "tapCount"
            <*> _o .:? "gestureSourceType"
        ago = A.withArray "synthesizeTapGesture" $ \_a -> SynthesizeTapGesture
            <$> P.maybe P.empty A.parseJSON (_a !? 0)
            <*> P.maybe P.empty A.parseJSON (_a !? 1)
            <*> P.traverse A.parseJSON (_a !? 2)
            <*> P.traverse A.parseJSON (_a !? 3)
            <*> P.traverse A.parseJSON (_a !? 4)


------------------------------------------------------------------------------
instance A.ToJSON SynthesizeTapGesture where
    toEncoding (SynthesizeTapGesture _0 _1 _2 _3 _4) = A.pairs $ P.fold $ P.catMaybes
        [ P.pure $ "x" .= _0
        , P.pure $ "y" .= _1
        , ("duration" .=) <$> _2
        , ("tapCount" .=) <$> _3
        , ("gestureSourceType" .=) <$> _4
        ]
    toJSON (SynthesizeTapGesture _0 _1 _2 _3 _4) = A.object $ P.catMaybes
        [ P.pure $ "x" .= _0
        , P.pure $ "y" .= _1
        , ("duration" .=) <$> _2
        , ("tapCount" .=) <$> _3
        , ("gestureSourceType" .=) <$> _4
        ]


------------------------------------------------------------------------------
instance P.Semigroup SynthesizeTapGesture where
    SynthesizeTapGesture _0 _1 _2 _3 _4 <> SynthesizeTapGesture _ _ __2 __3 __4 = SynthesizeTapGesture _0 _1 (_2 <|> __2) (_3 <|> __3) (_4 <|> __4)


------------------------------------------------------------------------------
instance M.Method SynthesizeTapGesture where
    type Result SynthesizeTapGesture = ()
    name _ = "Input.synthesizeTapGesture"


------------------------------------------------------------------------------
-- | Synthesizes a tap gesture over a time period by issuing appropriate touch events.
{-# WARNING synthesizeTapGesture "This feature is marked as EXPERIMENTAL." #-}
synthesizeTapGesture
    :: P.Double
    -- ^ X coordinate of the start of the gesture in CSS pixels.

    -> P.Double
    -- ^ Y coordinate of the start of the gesture in CSS pixels.

    -> SynthesizeTapGesture
synthesizeTapGesture _0 _1 = SynthesizeTapGesture _0 _1 P.empty P.empty P.empty

